/*
    jQuery Masked Input Plugin
    Copyright (c) 2007 - 2014 Josh Bush (digitalbush.com)
    Licensed under the MIT license (http://digitalbush.com/projects/masked-input-plugin/#license)
    Version: 1.4.0
*/

!function(a) { // Begin anonymous function
    "function" == typeof define && define.amd ? define(["jquery"], a) : a("object" == typeof exports ? require("jquery") : jQuery); // Check for AMD and CommonJS compatibility
}(function(a) { // Pass jQuery to the function
    var b, c = navigator.userAgent, // Store user agent in variable c
        d = /iphone/i.test(c), // Check if iPhone is being used
        e = /chrome/i.test(c), // Check if Chrome is being used
        f = /android/i.test(c); // Check if Android is being used

    a.mask = { // Object containing mask settings
        definitions: { // Object containing character definitions
            9: "[0-9]", // 9 represents any digit
            a: "[A-Za-z]", // a represents any letter
            "*": "[A-Za-z0-9]" // * represents any letter or digit
        },
        autoclear: true, // Automatically clear the input when the mask is applied
        dataName: "rawMaskFn", // Name of the data attribute used to store the raw mask function
        placeholder: "_" // Placeholder character
    };

    a.fn.extend({ // Extend jQuery with new methods
        caret: function(a, b) { // Method for setting or getting the caret position
            var c;
            if (0 !== this.length && !this.is(":hidden")) { // Check if the element exists and is not hidden
                return "number" == typeof a ? (b = "number" == typeof b ? b : a, // If a is a number, set the caret position
                    this.each(function() { // Loop through each element
                        this.setSelectionRange ? this.setSelectionRange(a, b) : // If setSelectionRange is supported, use it
                            this.createTextRange && (c = this.createTextRange(), // Otherwise, create a TextRange object
                                c.collapse(!0), c.moveEnd("character", b), c.moveStart("character", a), c.select()); // Set the caret position
                    })) : (this[0].setSelectionRange ? // If setSelectionRange is supported, return the caret position
                    (c = this[0].selectionStart, b = this[0].selectionEnd, {begin: c, end: b}) : // Otherwise, return undefined
                    document.selection && document.selection.createRange && (c = document.selection.createRange(), c.duplicate().moveStart("character", -1e5), {begin: 0 - c.duplicate().moveStart("character", -1e5), end: c.text.length})); // If createRange is supported, calculate the caret position
            }
        },
        unmask: function() { // Method for removing the mask from an input
            return this.trigger("unmask"); // Trigger the unmask event
        },
        mask: function(c, g) { // Method for applying a mask to an input
            var h, i, j, k, l, m, n, o;
            if (!c && this.length > 0) { // If no mask is provided and there is at least one element
                h = a(this[0]); // Get the first element
                var p = h.data(a.mask.dataName); // Get the raw mask function from the data attribute
                return p ? p() : void 0; // If the raw mask function exists, return it, otherwise return undefined
            }
            return g = a.extend({ // Extend the options object with default settings
                autoclear: a.mask.autoclear, // Set autoclear to the default value
                placeholder: a.mask.placeholder, // Set placeholder to the default value
                completed: null // Set completed to null
            }, g),
                i = a.mask.definitions, // Get the character definitions
                j = [], // Create an array to store the regex patterns
                k = n = c.length, // Set the length of the mask
                l = null, // Initialize the last non-null index
                a.each(c.split(""), function(a, b) { // Loop through each character in the mask
                    "?" == b ? (n--, k = a) : // If the character is a question mark, skip it and decrement n
                        i[b] ? (j.push(new RegExp(i[b])), // If the character is defined, add a regex pattern to the array
                            null === l && (l = j.length - 1), // If l is null, set it to the last non-null index
                            k > a && (m = j.length - 1)) : // If k is greater than a, set m to the last non-null index
                            j.push(null); // Otherwise, add a null value to the array
                }),
                this.trigger("unmask").each(function() { // Trigger the unmask event and loop through each element
                    function h() { // Function for checking if the input is complete
                        if (g.completed) { // If a completed callback is provided
                            for (var a = l; m >= a; a++) // Loop through each regex pattern
                                if (j[a] && C[a] === p(a)) // If the input matches the pattern
                                    return; // Exit the function
                            g.completed.call(B); // Otherwise, call the completed callback
                        }
                    }
                    function p(a) { // Function for getting the placeholder character
                        return g.placeholder.charAt(a < g.placeholder.length ? a : 0);
                    }
                    function q(a) { // Function for getting the next non-null index
                        for (; ++a < n;) // Loop through each index
                            if (j[a]) // If the
