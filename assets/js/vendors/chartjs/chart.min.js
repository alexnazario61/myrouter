class Chart {
  constructor(canvas) {
    this.canvas = canvas;
    this.ctx = canvas.getContext("2d");
    this.devicePixelRatio = window.devicePixelRatio || 1;

    this.FONT_FAMILY = "'Arial'";
    this.FONT_SIZE = 12;
    this.FONT_STYLE = "normal";
    this.FONT_COLOR = "#666";

    this.resize();
  }

  resize() {
    this.canvas.style.width = `${this.canvas.width}px`;
    this.canvas.style.height = `${this.canvas.height}px`;
    this.canvas.height = this.canvas.width * this.devicePixelRatio;
    this.canvas.width = this.canvas.height * this.devicePixelRatio;
    this.ctx.scale(this.devicePixelRatio, this.devicePixelRatio);
  }

  static lerp(t, a, b) {
    return a + (b - a) * t;
  }

  static clamp(value, min, max) {
    return Math.min(Math.max(value, min), max);
  }

  static map(value, sourceMin, sourceMax, destMin, destMax) {
    return (
      ((value - sourceMin) / (sourceMax - sourceMin)) * (destMax - destMin) +
      destMin
    );
  }

  static easeInQuad(t) {
    return t * t;
  }

  static easeOutQuad(t) {
    return -1 * t * (t - 2);
  }

  static easeInOutQuad(t) {
    return 1 > t ? 0.5 * t * t : 0.5 * ((t - 1) * (t - 2) - 1);
  }

  // ... Add more easing functions here

  animate(options, draw, complete) {
    const { animationSteps, animationEasing } = options;
    let step = 0;
    const easingFunction = Chart[animationEasing];

    function frame() {
      step++;
      if (step <= animationSteps) {
        const progress = easingFunction(step / animationSteps);
        draw(progress);
        requestAnimationFrame(frame);
      } else {
        if (complete) complete();
      }
    }

    requestAnimationFrame(frame);
  }

  // Add other chart types (PolarArea, Radar, Pie, Doughnut, Line, Bar) as methods here
}

// Usage:
const canvas = document.getElementById("chart-canvas");
const chart = new Chart(canvas);

// Configure and draw a chart
chart.drawPolarArea([
  { value: 30, color: "red" },
  { value: 50, color: "green" },
  { value: 100, color: "blue" },
]);
