(function ($, Plot) {

    // Helper function to parse and manipulate colors
    function parseColor(color, alpha) {
        var rgba = color.match(/^rgba\((\d+),(\d+),(\d+),(.+)\)$/);
        if (rgba) {
            return {
                r: parseInt(rgba[1], 10),
                g: parseInt(rgba[2], 10),
                b: parseInt(rgba[3], 10),
                a: parseFloat(rgba[4])
            };
        }

        var rgb = color.match(/^rgb\((\d+),(\d+),(\d+)\)$/);
        if (rgb) {
            return {
                r: parseInt(rgb[1], 10),
                g: parseInt(rgb[2], 10),
                b: parseInt(rgb[3], 10),
                a: 1
            };
        }

        var hex = color.match(/^#?([\da-fA-F]{2})([\da-fA-F]{2})([\da-fA-F]{2})$/);
        if (hex) {
            return {
                r: parseInt(hex[1], 16),
                g: parseInt(hex[2], 16),
                b: parseInt(hex[3], 16),
                a: alpha || 1
            };
        }

        throw new Error('Invalid color format: ' + color);
    }

    // Helper function to create a canvas element and return its 2D context
    function createCanvas(width, height) {
        var canvas = document.createElement('canvas');
        canvas.width = width;
        canvas.height = height;
        return getContext2D(canvas);
    }

    // Helper function to get the 2D context of a canvas element
    function getContext2D(canvas) {
        return canvas.getContext('2d');
    }

    // Helper function to clear a canvas element
    function clearCanvas(context) {
        context.clearRect(0, 0, context.canvas.width, context.canvas.height);
    }

    // Helper function to calculate the width of a text string
    function getTextWidth(context, text, font) {
        context.font = font;
        return context.measureText(text).width;
    }

    // Helper function to calculate the height of a text string
    function getTextHeight(context, font) {
        var metrics = context.measureText('M');
        return metrics.actualBoundingBoxDescent + metrics.actualBoundingBoxAscent;
    }

    // Helper function to draw grid lines
    function drawGridLines(context, grid, width, height) {
        context.save();
        context.strokeStyle = grid.color;
        context.lineWidth = grid.lineWidth;

        for (var i = 0; i <= grid.majorTicks; i++) {
            var y = height * (i / grid.majorTicks);
            context.beginPath();
            context.moveTo(0, y);
            context.lineTo(width, y);
            context.stroke();
        }

        context.restore();
    }

    // Helper function to draw axes
    function drawAxes(context, axis, width, height) {
        context.save();
        context.strokeStyle = axis.color;
        context.lineWidth = axis.lineWidth;

        context.beginPath();
        context.moveTo(axis.x, 0);
        context.lineTo(axis.x, height);
        context.stroke();

        context.beginPath();
        context.moveTo(0, axis.y);
        context.lineTo(width, axis.y);
        context.stroke();

        context.restore();
    }

    // Helper function to plot series lines
    function plotSeriesLines(context, series, xAxis, yAxis) {
        context.save();
        context.strokeStyle = series.color;
        context.lineWidth = series.lineWidth;

        context.beginPath();
        context.moveTo(xAxis.c2p(series.data[0].x), yAxis.c2p(series.data[0].y));

        for (var i = 1; i < series.data.length; i++) {
            context.lineTo(xAxis.c2p(series.data[i].x), yAxis.c2p(series.data[i].y));
        }

        context.stroke();
        context.restore();
    }

    // Helper function to plot series bars
    function plotSeriesBars(context, series, xAxis, yAxis) {
        context.save();
        context.fillStyle = series.color;
        context.lineWidth = series.lineWidth;

        for (var i = 0; i < series.data.length; i++) {
            var barWidth = (xAxis.max - xAxis.min) / series.data.length;
            var x = xAxis.c2p(series.data[i].x - barWidth /
