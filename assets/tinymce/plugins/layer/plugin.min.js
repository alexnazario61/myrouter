// Adds a new plugin called "layer" to TinyMCE
tinymce.PluginManager.add("layer", function(editor) {

  // Helper function to find the closest parent element with the class "mceItemLayer"
  function findLayerParent(element) {
    let parent = element;
    while (parent) {
      if (parent.className && parent.className.includes("mceItemLayer")) {
        return parent;
      }
      parent = parent.parentNode;
    }
    return null;
  }

  // Helper function to set the z-index of all layer elements
  function setLayerZIndex() {
    const dom = editor.dom;
    const layers = dom.select("div,p", editor.getBody());
    const layerIndexMap = {};
    let layerIndex = 0;

    tinymce.each(layers, function(layer) {
      if (/^(absolute|relative|fixed)$/i.test(layer.style.position)) {
        if (!layer.hasVisual) {
          dom.addClass(layer, "mceItemVisualAid");
        }
        dom.addClass(layer, "mceItemLayer");

        if (layer.style.zIndex) {
          layerIndexMap[parseInt(layer.style.zIndex, 10)] = layer;
        } else {
          layer.style.zIndex = layerIndex;
          layerIndex++;
        }
      }
    });

    // Set the z-index of each layer based on the calculated index map
    for (const index in layerIndexMap) {
      layerIndexMap[index].style.zIndex = layerIndex;
      layerIndex++;
    }
  }

  // Helper function to move a layer up or down in the z-index
  function moveLayer(direction) {
    const dom = editor.dom;
    const currentLayer = findLayerParent(editor.selection.getNode());
    let newIndex, targetLayer;

    if (currentLayer) {
      const layers = dom.select("div,p", editor.getBody());
      const currentIndex = Array.from(layers).indexOf(currentLayer);

      if (direction < 0) {
        for (let i = currentIndex - 1; i >= 0; i--) {
          if (layers[i].style.zIndex < layers[currentIndex].style.zIndex) {
            newIndex = i;
            targetLayer = layers[i];
            break;
          }
        }
      } else {
        for (let i = currentIndex + 1; i < layers.length; i++) {
          if (layers[i].style.zIndex > layers[currentIndex].style.zIndex) {
            newIndex = i;
            targetLayer = layers[i];
            break;
          }
        }
      }

      if (targetLayer) {
        const tempZIndex = currentLayer.style.zIndex;
        currentLayer.style.zIndex = targetLayer.style.zIndex;
        targetLayer.style.zIndex = tempZIndex;
      } else {
        currentLayer.style.zIndex = direction > 0 ? currentIndex + 1 : currentIndex - 1;
      }
    }

    editor.execCommand("mceRepaint");
  }

  // Helper function to toggle the absolute position of a layer
  function toggleAbsolutePosition() {
    const dom = editor.dom;
    const currentLayer = findLayerParent(editor.selection.getNode());

    if (currentLayer) {
      if (/absolute|relative|fixed/.test(currentLayer.style.position.toLowerCase())) {
        if (currentLayer.style.position === "absolute") {
          dom.setStyles(currentLayer, {
            position: "",
            left: "",
            top: "",
            width: "",
            height: ""
          });
          dom.removeClass(currentLayer, "mceItemVisualAid");
          dom.removeClass(currentLayer, "mceItemLayer");
        } else {
          currentLayer.style.left || (currentLayer.style.left = "20px");
          currentLayer.style.top || (currentLayer.style.top = "20px");
          currentLayer.style.width || (currentLayer.style.width = currentLayer.width + "px");
          currentLayer.style.height || (currentLayer.style.height = currentLayer.height + "px");
          currentLayer.style.position = "absolute";
          dom.setAttrib(currentLayer, "data-mce-style", "");
          editor.addVisual(editor.getBody());
        }
        editor.execCommand("mceRepaint");
        editor.nodeChanged();
      }
    }
  }

  // Registers commands for inserting
