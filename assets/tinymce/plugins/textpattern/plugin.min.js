tinymce.PluginManager.add("textpattern", function(editor) {
  // Define a function that sorts the patterns based on the length of their start string
  function sortPatterns() {
    patterns.sort(function(a, b) {
      return a.start.length > b.start.length ? -1 : a.start.length < b.start.length ? 1 : 0;
    });
  }

  // Define a function that finds the pattern that matches the given text
  function findPattern(text) {
    for (var i = 0; i < patterns.length; i++) {
      if (text.indexOf(patterns[i].start) === 0 && (!patterns[i].end || text.lastIndexOf(patterns[i].end) === text.length - patterns[i].end.length)) {
        return patterns[i];
      }
    }
  }

  // Define a function that finds the pattern that matches the given text, taking into account the given offset
  function findPatternAtOffset(text, offset) {
    for (var i = 0; i < patterns.length; i++) {
      if (patterns[i].end && text.substr(offset - patterns[i].end.length, patterns[i].end.length) === patterns[i].end) {
        return patterns[i];
      }
    }
  }

  // Define a function that applies the given pattern to the selected text
  function applyPattern(pattern) {
    if (pattern.format) {
      var formatter = editor.formatter.get(pattern.format);
      if (formatter && formatter[0].inline) {
        // If the pattern has a format and the format is inline, apply the format to the selected text
        editor.formatter.apply(pattern.format, {}, editor.selection.getNode());
      } else if (pattern.cmd) {
        // If the pattern has a command, execute the command on the selected text
        editor.undoManager.transact(function() {
          editor.selection.getNode().deleteData(0, pattern.start.length);
          editor.execCommand(pattern.cmd);
        });
      }
    }
  }

  // Define a function that inserts a space after the selected text if the selection ends with a certain character
  function insertSpace() {
    var selection = editor.selection,
      dom = editor.dom,
      node = selection.startContainer,
      offset = selection.startOffset;

    if (selection.isCollapsed() && node.nodeType === 3) {
      var pattern = findPatternAtOffset(node.data, offset);
      if (pattern && pattern.end && /[\u00a0 ]/.test(node.data.slice(-1))) {
        var textNode = dom.createTextNode(node.data.slice(-1)),
          range = dom.createRng();

        range.setStart(node, offset);
        range.setEnd(node, offset);
        selection.setRng(range);

        node.deleteData(offset - pattern.end.length, pattern.end.length);
        dom.insertAfter(textNode, node.nextSibling || node.parentNode.lastChild);

        range.setStart(textNode, 1);
        range.setEnd(textNode, 1);
        selection.setRng(range);
      }
    }
  }

  // Define an array of patterns
  var patterns = editor.settings.textpattern_patterns || [
    { start: "*", end: "*", format: "italic" },
    { start: "**", end: "**", format: "bold" },
    { start: "#", format: "h1" },
    { start: "##", format: "h2" },
    { start: "###", format: "h3" },
    { start: "####", format: "h4" },
    { start: "#####", format: "h5" },
    { start: "######", format: "h6" },
    { start: "1. ", cmd: "InsertOrderedList" },
    { start: "* ", cmd: "InsertUnorderedList" },
    { start: "- ", cmd: "InsertUnorderedList" }
  ];

  // Sort the patterns based on the length of their start string
  sortPatterns();

  // Define a keydown handler that applies the appropriate pattern when the user presses enter
  editor.on("keydown", function(event) {
    if (event.keyCode === 13 && !tinymce.util.VK.
